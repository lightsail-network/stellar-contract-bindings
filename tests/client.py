# This file was generated by stellar_contract_bindings v0.1.0b0 and stellar_sdk v12.0.0b6.
# Client is used to interact with the contract on the Stellar network synchronously,
# while ClientAsync is used to interact with the contract on the Stellar network asynchronously.
# If you don't need to interact with the contract asynchronously, you can remove the ClientAsync class and its methods.

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import (
    AssembledTransaction,
    AssembledTransactionAsync,
    ContractClient,
    ContractClientAsync,
)

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class Test:
    """This is from the rust doc above the struct Test"""

    a: int
    b: bool
    c: str

    def __init__(self, a: int, b: bool, c: str):
        self.a = a
        self.b = b
        self.c = c

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "a": scval.to_uint32(self.a),
                "b": scval.to_bool(self.b),
                "c": scval.to_symbol(self.c),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["a"]),
            scval.from_bool(elements["b"]),
            scval.from_symbol(elements["c"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Test):
            return NotImplemented
        return self.a == other.a and self.b == other.b and self.c == other.c

    def __hash__(self) -> int:
        return hash((self.a, self.b, self.c))


class SimpleEnumKind(Enum):
    First = "First"
    Second = "Second"
    Third = "Third"


class SimpleEnum:
    def __init__(
        self,
        kind: SimpleEnumKind,
    ):
        self.kind = kind

    def to_scval(self) -> xdr.SCVal:
        if self.kind == SimpleEnumKind.First:
            return scval.to_enum(self.kind.name, None)
        if self.kind == SimpleEnumKind.Second:
            return scval.to_enum(self.kind.name, None)
        if self.kind == SimpleEnumKind.Third:
            return scval.to_enum(self.kind.name, None)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = SimpleEnumKind(elements[0])
        if kind == SimpleEnumKind.First:
            return cls(kind)
        if kind == SimpleEnumKind.Second:
            return cls(kind)
        if kind == SimpleEnumKind.Third:
            return cls(kind)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, SimpleEnum):
            return NotImplemented
        if self.kind != other.kind:
            return False
        return True

    def __hash__(self) -> int:
        return hash(self.kind)


class RoyalCard(IntEnum):
    Jack = 11
    Queen = 12
    King = 13

    def to_scval(self) -> xdr.SCVal:
        return scval.to_uint32(self.value)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        return cls(scval.from_uint32(val))


class TupleStruct:

    def __init__(self, value: Tuple[Test, SimpleEnum]):
        self.value = value

    def to_scval(self) -> xdr.SCVal:
        return scval.to_tuple_struct(
            [self.value[0].to_scval(), self.value[1].to_scval()]
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_tuple_struct(val)
        values = (
            Test.from_scval(elements[0]),
            SimpleEnum.from_scval(elements[1]),
        )
        return cls(values)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, TupleStruct):
            return NotImplemented
        return self.value == other.value

    def __hash__(self) -> int:
        return hash(self.value)


class ComplexEnumKind(Enum):
    Struct = "Struct"
    Tuple = "Tuple"
    Enum = "Enum"
    Asset = "Asset"
    Void = "Void"


class ComplexEnum:
    def __init__(
        self,
        kind: ComplexEnumKind,
        struct: Optional[Test] = None,
        tuple: Optional[TupleStruct] = None,
        enum: Optional[SimpleEnum] = None,
        asset: Optional[Tuple[Address, int]] = None,
    ):
        self.kind = kind
        self.struct = struct
        self.tuple = tuple
        self.enum = enum
        self.asset = asset

    def to_scval(self) -> xdr.SCVal:
        if self.kind == ComplexEnumKind.Struct:
            return scval.to_enum(self.kind.name, self.struct.to_scval())
        if self.kind == ComplexEnumKind.Tuple:
            return scval.to_enum(self.kind.name, self.tuple.to_scval())
        if self.kind == ComplexEnumKind.Enum:
            return scval.to_enum(self.kind.name, self.enum.to_scval())
        if self.kind == ComplexEnumKind.Asset:
            return scval.to_enum(
                self.kind.name,
                [scval.to_address(self.asset[0]), scval.to_int128(self.asset[1])],
            )
        if self.kind == ComplexEnumKind.Void:
            return scval.to_enum(self.kind.name, None)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = ComplexEnumKind(elements[0])
        if kind == ComplexEnumKind.Struct:
            return cls(kind, struct=Test.from_scval(elements[1]))
        if kind == ComplexEnumKind.Tuple:
            return cls(kind, tuple=TupleStruct.from_scval(elements[1]))
        if kind == ComplexEnumKind.Enum:
            return cls(kind, enum=SimpleEnum.from_scval(elements[1]))
        if kind == ComplexEnumKind.Asset:
            return cls(
                kind,
                asset=(
                    scval.from_address(elements[1][0]),
                    scval.from_int128(elements[1][1]),
                ),
            )
        if kind == ComplexEnumKind.Void:
            return cls(kind)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ComplexEnum):
            return NotImplemented
        if self.kind != other.kind:
            return False
        if self.kind == ComplexEnumKind.Struct:
            return self.struct == other.struct
        if self.kind == ComplexEnumKind.Tuple:
            return self.tuple == other.tuple
        if self.kind == ComplexEnumKind.Enum:
            return self.enum == other.enum
        if self.kind == ComplexEnumKind.Asset:
            return self.asset == other.asset
        return True

    def __hash__(self) -> int:
        if self.kind == ComplexEnumKind.Struct:
            return hash((self.kind, self.struct))
        if self.kind == ComplexEnumKind.Tuple:
            return hash((self.kind, self.tuple))
        if self.kind == ComplexEnumKind.Enum:
            return hash((self.kind, self.enum))
        if self.kind == ComplexEnumKind.Asset:
            return hash((self.kind, self.asset))
        return hash(self.kind)


class Error(IntEnum):
    NumberMustBeOdd = 1

    def to_scval(self) -> xdr.SCVal:
        return scval.to_uint32(self.value)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        return cls(scval.from_uint32(val))


class Client(ContractClient):
    def hello(
        self,
        hello: str,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[str]:
        return self.invoke(
            "hello",
            [scval.to_symbol(hello)],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def void(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "void",
            [],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def val(
        self,
        a: int,
        b: xdr.SCVal,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[xdr.SCVal]:
        return self.invoke(
            "val",
            [scval.to_uint32(a), b],
            parse_result_xdr_fn=lambda v: v,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def u32_fail_on_even(
        self,
        u32_: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "u32_fail_on_even",
            [scval.to_uint32(u32_)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def u32(
        self,
        u32: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "u32",
            [scval.to_uint32(u32)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def i32(
        self,
        i32: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "i32",
            [scval.to_int32(i32)],
            parse_result_xdr_fn=lambda v: scval.from_int32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def u64(
        self,
        u64: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "u64",
            [scval.to_uint64(u64)],
            parse_result_xdr_fn=lambda v: scval.from_uint64(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def i64(
        self,
        i64: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "i64",
            [scval.to_int64(i64)],
            parse_result_xdr_fn=lambda v: scval.from_int64(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def strukt_hel(
        self,
        strukt: Test,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[str]]:
        """Example contract method which takes a struct"""
        return self.invoke(
            "strukt_hel",
            [strukt.to_scval()],
            parse_result_xdr_fn=lambda v: [
                scval.from_symbol(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def strukt(
        self,
        strukt: Test,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Test]:
        return self.invoke(
            "strukt",
            [strukt.to_scval()],
            parse_result_xdr_fn=lambda v: Test.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def simple(
        self,
        simple: SimpleEnum,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[SimpleEnum]:
        return self.invoke(
            "simple",
            [simple.to_scval()],
            parse_result_xdr_fn=lambda v: SimpleEnum.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def complex(
        self,
        complex: ComplexEnum,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[ComplexEnum]:
        return self.invoke(
            "complex",
            [complex.to_scval()],
            parse_result_xdr_fn=lambda v: ComplexEnum.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def address(
        self,
        address: Address,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "address",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def bytes(
        self,
        bytes: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        return self.invoke(
            "bytes",
            [scval.to_bytes(bytes)],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def bytes_n(
        self,
        bytes_n: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        return self.invoke(
            "bytes_n",
            [scval.to_bytes(bytes_n)],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def card(
        self,
        card: RoyalCard,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[RoyalCard]:
        return self.invoke(
            "card",
            [card.to_scval()],
            parse_result_xdr_fn=lambda v: RoyalCard.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def boolean(
        self,
        boolean: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "boolean",
            [scval.to_bool(boolean)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def not_(
        self,
        boolean: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        """Negates a boolean value"""
        return self.invoke(
            "not_",
            [scval.to_bool(boolean)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def i128(
        self,
        i128: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "i128",
            [scval.to_int128(i128)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def u128(
        self,
        u128: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "u128",
            [scval.to_uint128(u128)],
            parse_result_xdr_fn=lambda v: scval.from_uint128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def multi_args(
        self,
        a: int,
        b: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "multi_args",
            [scval.to_uint32(a), scval.to_bool(b)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def map(
        self,
        map: Dict[int, bool],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Dict[int, bool]]:
        return self.invoke(
            "map",
            [
                scval.to_map(
                    {scval.to_uint32(k): scval.to_bool(v) for k, v in map.items()}
                )
            ],
            parse_result_xdr_fn=lambda v: {
                scval.from_uint32(k): scval.from_bool(v)
                for k, v in scval.from_map(v).items()
            },
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def vec(
        self,
        vec: List[int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[int]]:
        return self.invoke(
            "vec",
            [scval.to_vec([scval.to_uint32(e) for e in vec])],
            parse_result_xdr_fn=lambda v: [
                scval.from_uint32(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def tuple(
        self,
        tuple: Tuple[str, int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Tuple[str, int]]:
        return self.invoke(
            "tuple",
            [
                scval.to_tuple_struct(
                    [scval.to_symbol(tuple[0]), scval.to_uint32(tuple[1])]
                )
            ],
            parse_result_xdr_fn=lambda v: (
                scval.from_symbol(scval.from_tuple_struct(v)[0]),
                scval.from_uint32(scval.from_tuple_struct(v)[1]),
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def empty_tuple(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "empty_tuple",
            [],
            parse_result_xdr_fn=lambda v: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def option(
        self,
        option: Optional[int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Optional[int]]:
        """Example of an optional argument"""
        return self.invoke(
            "option",
            [scval.to_uint32(option) if option is not None else scval.to_void()],
            parse_result_xdr_fn=lambda v: (
                scval.from_uint32(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def u256(
        self,
        u256: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "u256",
            [scval.to_uint256(u256)],
            parse_result_xdr_fn=lambda v: scval.from_uint256(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def i256(
        self,
        i256: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "i256",
            [scval.to_int256(i256)],
            parse_result_xdr_fn=lambda v: scval.from_int256(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def string(
        self,
        string: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        return self.invoke(
            "string",
            [scval.to_string(string)],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def tuple_strukt(
        self,
        tuple_strukt: TupleStruct,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[TupleStruct]:
        return self.invoke(
            "tuple_strukt",
            [tuple_strukt.to_scval()],
            parse_result_xdr_fn=lambda v: TupleStruct.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def tuple_strukt_nested(
        self,
        tuple_strukt: Tuple[Test, SimpleEnum],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Tuple[Test, SimpleEnum]]:
        return self.invoke(
            "tuple_strukt_nested",
            [
                scval.to_tuple_struct(
                    [tuple_strukt[0].to_scval(), tuple_strukt[1].to_scval()]
                )
            ],
            parse_result_xdr_fn=lambda v: (
                Test.from_scval(scval.from_tuple_struct(v)[0]),
                SimpleEnum.from_scval(scval.from_tuple_struct(v)[1]),
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def timepoint(
        self,
        timepoint: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "timepoint",
            [scval.to_timepoint(timepoint)],
            parse_result_xdr_fn=lambda v: scval.from_timepoint(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def duration(
        self,
        duration: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "duration",
            [scval.to_duration(duration)],
            parse_result_xdr_fn=lambda v: scval.from_duration(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def hello(
        self,
        hello: str,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[str]:
        return await self.invoke(
            "hello",
            [scval.to_symbol(hello)],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def void(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "void",
            [],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def val(
        self,
        a: int,
        b: xdr.SCVal,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[xdr.SCVal]:
        return await self.invoke(
            "val",
            [scval.to_uint32(a), b],
            parse_result_xdr_fn=lambda v: v,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def u32_fail_on_even(
        self,
        u32_: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "u32_fail_on_even",
            [scval.to_uint32(u32_)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def u32(
        self,
        u32: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "u32",
            [scval.to_uint32(u32)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def i32(
        self,
        i32: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "i32",
            [scval.to_int32(i32)],
            parse_result_xdr_fn=lambda v: scval.from_int32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def u64(
        self,
        u64: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "u64",
            [scval.to_uint64(u64)],
            parse_result_xdr_fn=lambda v: scval.from_uint64(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def i64(
        self,
        i64: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "i64",
            [scval.to_int64(i64)],
            parse_result_xdr_fn=lambda v: scval.from_int64(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def strukt_hel(
        self,
        strukt: Test,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[str]]:
        """Example contract method which takes a struct"""
        return await self.invoke(
            "strukt_hel",
            [strukt.to_scval()],
            parse_result_xdr_fn=lambda v: [
                scval.from_symbol(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def strukt(
        self,
        strukt: Test,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Test]:
        return await self.invoke(
            "strukt",
            [strukt.to_scval()],
            parse_result_xdr_fn=lambda v: Test.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def simple(
        self,
        simple: SimpleEnum,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[SimpleEnum]:
        return await self.invoke(
            "simple",
            [simple.to_scval()],
            parse_result_xdr_fn=lambda v: SimpleEnum.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def complex(
        self,
        complex: ComplexEnum,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[ComplexEnum]:
        return await self.invoke(
            "complex",
            [complex.to_scval()],
            parse_result_xdr_fn=lambda v: ComplexEnum.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def address(
        self,
        address: Address,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "address",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def bytes(
        self,
        bytes: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        return await self.invoke(
            "bytes",
            [scval.to_bytes(bytes)],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def bytes_n(
        self,
        bytes_n: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        return await self.invoke(
            "bytes_n",
            [scval.to_bytes(bytes_n)],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def card(
        self,
        card: RoyalCard,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[RoyalCard]:
        return await self.invoke(
            "card",
            [card.to_scval()],
            parse_result_xdr_fn=lambda v: RoyalCard.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def boolean(
        self,
        boolean: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "boolean",
            [scval.to_bool(boolean)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def not_(
        self,
        boolean: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        """Negates a boolean value"""
        return await self.invoke(
            "not_",
            [scval.to_bool(boolean)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def i128(
        self,
        i128: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "i128",
            [scval.to_int128(i128)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def u128(
        self,
        u128: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "u128",
            [scval.to_uint128(u128)],
            parse_result_xdr_fn=lambda v: scval.from_uint128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def multi_args(
        self,
        a: int,
        b: bool,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "multi_args",
            [scval.to_uint32(a), scval.to_bool(b)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def map(
        self,
        map: Dict[int, bool],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Dict[int, bool]]:
        return await self.invoke(
            "map",
            [
                scval.to_map(
                    {scval.to_uint32(k): scval.to_bool(v) for k, v in map.items()}
                )
            ],
            parse_result_xdr_fn=lambda v: {
                scval.from_uint32(k): scval.from_bool(v)
                for k, v in scval.from_map(v).items()
            },
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def vec(
        self,
        vec: List[int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[int]]:
        return await self.invoke(
            "vec",
            [scval.to_vec([scval.to_uint32(e) for e in vec])],
            parse_result_xdr_fn=lambda v: [
                scval.from_uint32(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def tuple(
        self,
        tuple: Tuple[str, int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Tuple[str, int]]:
        return await self.invoke(
            "tuple",
            [
                scval.to_tuple_struct(
                    [scval.to_symbol(tuple[0]), scval.to_uint32(tuple[1])]
                )
            ],
            parse_result_xdr_fn=lambda v: (
                scval.from_symbol(scval.from_tuple_struct(v)[0]),
                scval.from_uint32(scval.from_tuple_struct(v)[1]),
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def empty_tuple(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "empty_tuple",
            [],
            parse_result_xdr_fn=lambda v: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def option(
        self,
        option: Optional[int],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Optional[int]]:
        """Example of an optional argument"""
        return await self.invoke(
            "option",
            [scval.to_uint32(option) if option is not None else scval.to_void()],
            parse_result_xdr_fn=lambda v: (
                scval.from_uint32(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def u256(
        self,
        u256: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "u256",
            [scval.to_uint256(u256)],
            parse_result_xdr_fn=lambda v: scval.from_uint256(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def i256(
        self,
        i256: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "i256",
            [scval.to_int256(i256)],
            parse_result_xdr_fn=lambda v: scval.from_int256(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def string(
        self,
        string: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        return await self.invoke(
            "string",
            [scval.to_string(string)],
            parse_result_xdr_fn=lambda v: scval.from_string(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def tuple_strukt(
        self,
        tuple_strukt: TupleStruct,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[TupleStruct]:
        return await self.invoke(
            "tuple_strukt",
            [tuple_strukt.to_scval()],
            parse_result_xdr_fn=lambda v: TupleStruct.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def tuple_strukt_nested(
        self,
        tuple_strukt: Tuple[Test, SimpleEnum],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Tuple[Test, SimpleEnum]]:
        return await self.invoke(
            "tuple_strukt_nested",
            [
                scval.to_tuple_struct(
                    [tuple_strukt[0].to_scval(), tuple_strukt[1].to_scval()]
                )
            ],
            parse_result_xdr_fn=lambda v: (
                Test.from_scval(scval.from_tuple_struct(v)[0]),
                SimpleEnum.from_scval(scval.from_tuple_struct(v)[1]),
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def timepoint(
        self,
        timepoint: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "timepoint",
            [scval.to_timepoint(timepoint)],
            parse_result_xdr_fn=lambda v: scval.from_timepoint(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def duration(
        self,
        duration: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Keypair = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "duration",
            [scval.to_duration(duration)],
            parse_result_xdr_fn=lambda v: scval.from_duration(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
